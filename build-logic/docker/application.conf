pekko {
  loglevel = DEBUG
  loggers = ["org.apache.pekko.event.slf4j.Slf4jLogger"]
  logging-filter = "org.apache.pekko.event.slf4j.Slf4jLoggingFilter"
  logger-startup-timeout = 30s

  # !must be setup, because we need to serialize coap connection_id!
  serialization {
    jackson {
      jackson-modules += "io.kaxis.serialization.KaxisJacksonModule"
      # PekkoStreamsModule optionally included if akka-streams is in classpath
      jackson-modules += "com.fasterxml.jackson.module.paramnames.ParameterNamesModule"
      jackson-modules += "com.fasterxml.jackson.datatype.jdk8.Jdk8Module"
      jackson-modules += "com.fasterxml.jackson.datatype.jsr310.JavaTimeModule"
      jackson-modules += "com.fasterxml.jackson.module.scala.DefaultScalaModule"
      jackson-modules += "com.fasterxml.jackson.module.kotlin.KotlinModule"
    }
  }

  actor {
    provider = cluster
    serialization-bindings {
      "io.kaxis.CborSerializable" = jackson-cbor
    }
    serialize-messages = on
    allow-java-serialization = on
    debug {
      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = on
      # enable DEBUG logging of unhandled messages
      unhandled = on
    }
  }

  # For the sample, just bind to loopback and do not allow access from the network
  # the port is overridden by the logic in main class
  remote.artery {
    canonical.hostname = 127.0.0.1
    canonical.hostname = ${?HOST_NAME}
    canonical.port = 0
    canonical.port = ${?HOST_PORT}
    log-frame-size-exceeding = 10000b
    advanced {
      # heartbeat interval of pekko cluster.
      maximum-frame-size = 2MiB
    }
  }

  cluster {
    # This can also be defined as Java system properties when starting the JVM using the following syntax:
    #
    # -Dpekko.cluster.seed-nodes.0=pekko://Kaxis@seed1:4684
    # -Dpekko.cluster.seed-nodes.1=pekko://Kaxis@seed2:4685
    #
    seed-nodes = [
      "pekko://Kaxis@127.0.0.1:4684",
      "pekko://Kaxis@127.0.0.1:4685"]
    seed-nodes = ${?SEED_NODES}
    roles = ["seed", "sharding"]
    roles = ${?ROLES}
    sharding.role = "sharding"
    sharding.role = ${?SHARDING_ROLE}
    min-nr-of-members = 2
    debug {
      verbose-gossip-logging: on
      verbose-heartbeat-logging: on
    }
    failure-detector {
      acceptable-heartbeat-pause = 5s
      threshold = 10.0
    }
    sharding {
      passivation {
        default-idle-strategy {
          idle-entity {
            timeout = 10 minutes
          }
        }
      }
      # Number of shards used by the default HashCodeMessageExtractor
      # when no other message extractor is defined. This value must be
      # the same for all nodes in the cluster and that is verified by
      # configuration check when joining. Changing the value requires
      # stopping all nodes in the cluster.
      number-of-shards = 1000
      # When this is set to 'on' the active entity actors will automatically be restarted
      # upon Shard restart. i.e. if the Shard is started on a different ShardRegion
      # due to rebalance or crash.
      remember-entities = on
      remember-entities-store = ddata
      # To support restarting entities after a full cluster restart
      # (non-rolling) the remember entities store is persisted to disk
      # by distributed data. This can be disabled if not needed:
      distributed-data {
        durable.keys = []
      }
    }
    jmx {
      multi-mbeans-in-same-jvm = on
    }
    shutdown-after-unsuccessful-join-seed-nodes = 20s
    downing-provider-class = "org.apache.pekko.cluster.sbr.SplitBrainResolverProvider"
    split-brain-resolver {
      active-strategy = keep-majority
    }
    run-coordinated-shutdown-when-down = on
  }
  # ganrantee peer side closed.
  jvm-shutdown-hooks = on
  coordinated-shutdown {
    run-by-actor-system-terminate = on
    run-by-jvm-shutdown-hook = on
    terminate-actor-system = on
    exit-jvm = on
  }
  # management
  management {
    http.hostname = 127.0.0.1
    http.hostname = ${?HOST_NAME}
    http.bind-hostname = 0.0.0.0
    http.bind-hostname = ${?HOST_NAME}
    health-checks {
      readiness-path = "health/ready"
      liveness-path = "health/alive"
      readiness-checks {
        # Default health check for cluster.
        cluster-membership = "org.apache.pekko.management.cluster.javadsl.ClusterMembershipCheck"
      }
    }
  }

  extensions = [org.apache.pekko.persistence.Persistence]
  # Test locally sharding inmem
  persistence {
    journal {
      plugin = "pekko.persistence.journal.inmem"
      auto-start-journals = ["pekko.persistence.journal.inmem"]
    }
    snapshot-store {
      plugin = "pekko.persistence.snapshot-store.local"
      auto-start-snapshot-stores = ["pekko.persistence.snapshot-store.local"]
    }
    state {
      plugin = "kaxis.inmem-store"
    }
  }
}


kaxis {
  routes.ask-timeout = 60s

  inmem-store {
    class = "io.kaxis.store.RedisStoreProvider"
    redis.url = "redis://localhost:6379"
  }

  dtls {
    USE_HELLO_VERIFY_REQUEST = true
    USE_ANTI_REPLAY_FILTER = true
    USE_DISABLED_WINDOW_FOR_ANTI_REPLAY_FILTER = 0
    UPDATE_ADDRESS_USING_CID_ON_NEWER_RECORDS = true
    PROTOCOL_VERSION_FOR_HELLO_VERIFY_REQUESTS = "1.2"
    CONNECTION_ID_LENGTH = 6
    TRUNCATE_CLIENT_CERTIFICATE_PATH = true
    TRUNCATE_CERTIFICATE_PATH_FOR_VALIDATION = true
    RECOMMENDED_CIPHER_SUITES_ONLY = true
    RECOMMENDED_CURVES_ONLY = true
    RECOMMENDED_SIGNATURE_AND_HASH_ALGORITHMS_ONLY = true
    PRESELECTED_CIPHER_SUITES = [
      "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256",
      "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384",
      "TLS_ECDHE_ECDSA_WITH_AES_128_CCM",
      "TLS_ECDHE_ECDSA_WITH_AES_256_CCM",
      "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
      "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
      "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256",
      "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384",
      "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
      "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
      "TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256",
      "TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA378",
      "TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256",
      "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
      "TLS_PSK_WITH_AES_128_GCM_SHA256",
      "TLS_PSK_WITH_AES_256_GCM_SHA378",
      "TLS_PSK_WITH_AES_128_CCM",
      "TLS_PSK_WITH_AES_256_CCM",
      "TLS_PSK_WITH_AES_128_CBC_SHA256",
      "TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8",
      "TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8",
      "TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256",
      "TLS_PSK_WITH_AES_128_CCM_8",
      "TLS_PSK_WITH_AES_256_CCM_8"
    ]
    CIPHER_SUITES = []
    # RFC 6066, Section 3
    USE_SERVER_NAME_INDICATION = false
    EXTENDED_MASTER_SECRET_MODE = "ENABLED"
    CURVES = [
      "secp256r1",
      "secp384r1",
      "secp521r1",
      "X25519",             # if supported by JCE
      "X448"                # if supported by JCE
    ]
    SIGNATURE_AND_HASH_ALGORITHMS = [
      "SHA256withECDSA",
      "ED25519"
    ]
    CLIENT_AUTHENTICATION_MODE = "NEEDED"
    VERIFY_SERVER_CERTIFICATES_SUBJECT = true
    CERTIFICATE_TYPES = [
      "RAW_PUBLIC_KEY",
      "X_509"
    ]
    # MTU/PMTU
    MAX_TRANSMISSION_UNIT = 64
    MAX_TRANSMISSION_UNIT_LIMIT = 1500
    SECURE_RENEGOTIATION_MODE = "WANTED"
    SUPPORT_KEY_MATERIAL_EXPORT = false
    KEY_STORE_PASSWORD = "endPass"
    KEY_STORE_LOCATION = "certs/keyStore.jks"
    TRUST_STORE_PASSWORD = "rootPass"
    TRUST_STORE_LOCATION = "certs/trustStore.jks"
  }
}
